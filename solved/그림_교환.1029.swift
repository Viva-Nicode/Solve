import Foundation

func solve_1029() {
    let fio = FileIO()
    let n = fio.readInt()
    var dp = [[[Int]]](repeating: [[Int]](repeating: [Int](repeating: 0, count: n), count: n), count: 2^^n)
    let table: [[Int]] = (0..<n).map { _ in fio.readString().map { Int(String($0))! } }
    let bits: [UInt16] = (0..<n).map { 0b000000000000000 | (1 << $0) }

    func dfs(_ visited: UInt16, _ artist: Int, _ price: Int) {
        let sellable = table[artist]

        for i in 0..<sellable.count {
            let saleCount = visited.nonzeroBitCount
            let isVisited = visited & (1 << i) == 0
            if isVisited && price <= sellable[i] && dp[Int(visited)][artist][i] < saleCount + 1 {
                dp[Int(visited)][artist][i] = saleCount + 1
                dfs(visited | bits[i], i, sellable[i])
            }
        }
    }

    dfs(bits[0], 0, 0)
    print(dp.map { $0.map { $0.max()! }.max()! }.max()!)
}

/*
 https://www.acmicpc.net/problem/1029
 2025.2.18
 
 DFS를 통해 탐색하면서 비트마스킹이 포함된 3차원 DP를 이용한 백트래킹 문제이다.
 
 처음엔 DP를 아래와 같이 구성하였다.
 
 (n * n) 사이즈의 2차원 배열 dp:[[Int]], n사이즈의 visited:[Bool]
 
 dp[i][j] 는 i가 소유한 그림을 j가 구매했을 때 그림을 거쳐간 소유권자들의 수의 최댓값을 의미한다.
 
 한번 구매한사람은 다시 구매하지 못한다는 조건이 있었기 때문에 visited배열을 통해 이미 구매했는지 아닌지 검사했다.
 
 따라서 DFS를 통해 탐색할 때, 해당 경우를 탐색할지 말지 결정하는 조건은 아래와 같았다.
 
 if (visited를 보고 구매한 기록이 없다면 true) && (현재 가격 <= 구매하려는 가격) && (dp[i][j] < visited중 true의 갯수) {
    // 해당 경우를 탐색한다.
    dfs()
 }
 
 제공되는 테스트 케이스는 전부 통과했으나 제출 시 1%에서 틀렸습니다를 받았다.
 
 잘못된 부분은 3번째 조건인 (dp[i][j] < visited중 true의 갯수)이었는데,
 
 문제에 의하면 거쳐간 아티스트의 수뿐만 아니라 몇번 몇번 아티스트를 거쳐갔는지도 백트래킹 조건에 포험시켜야 한다. 이유는 아래와 같다.
 
 사람수가 7명이라 가정하자.(아래는 예시일 뿐, DFS는 실제로 이런 순서로 탐색되지도 않는다. 이런 일이 발생할 수도있다는 단적인 예시이다.)
 
 첫번째 탐색은 아래와 같다고 가정하자.
 1 -> 4 -> 5 -> 2 -> 3
 
 3이 구매한 다음 구매 가능한 사람이 전부 공짜로 사려고한다거나 하는 이유로 여기서 탐색이 중지되었다고 가정하자.
 
 이 경우 dp에는 아래와 같은 값이 저장된다.
 
 dp[1][4] = 2
 dp[4][5] = 3
 dp[5][2] = 4
 dp[2][3] = 5
 
 하지만 다음 탐색이 아래와 같다고 가정해보자.
 
 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7
 
 2가 3에게 판매할 때, dp[2][3]는 5 이고 현재 거쳐간 사람수는 2이므로 더이상 탐색하지 않는다.
 
 팔았다면 7번까지 소유권자를 늘릴 수 있음에도 불구하고.
 
 따라서 몇번 몇번 사람이 구매했는지도 DP에 저장해주고 백트래킹 조건으로 이용해 주어야 한다.
 
 몇번 아티스트를 거쳐갔는지를 표현하는 방법으로 비트마스킹을 사용하였다.
 
 사람수가 최대 15이므로 15개의 비트로 표현가능하다.
 
 dp를 3차원으로 확장하였다.
 
 사람수가 15이고 Int자료형을 사용한다면 (15 * 15 * 2^15) * 4 byte = 30mb 정도가 사용된다.
 
 따라서 DP변수와 문제였던 3번째 조건은 아래와 같아졌다.
 
 var dp = [[[Int]]](repeating: [[Int]](repeating: [Int](repeating: 0, count: n), count: n), count: 2^^n)
 
 // dp[거쳐간 소유권자들][파는사람][사는사람]
 dp[Int(visited)][artist][i] < saleCount + 1
 
 통과
 
 */

/*
3
022
101
110
 2

2
01
10
 2
 
5
01231
00231
00031
00002
00000
 4
 
5
15555
11111
15111
11111
11111
 3
 
10
0100000000
0020000000
0003000000
0000400000
0000050000
0000006000
0000000700
0000000080
0000000009
1111111111
 10
 
5
01199
00530
02060
00004
00000
 5
 
13
3675356291270
9360626187920
2375922897361
2931947845036
1063206155476
5693745254744
3078688431492
0689266495048
7172722610615
9490917711597
7673656394812
9390885096385
6115984810304
 13
 
13
9899998899898
9360626187920
2375922897361
2931947845036
1063206155476
5693745254744
3078688431492
0689266495048
7172722610615
9490917711597
7673656394812
9390885096385
6115984810304
 8
 
15
111111111111111
111111111111111
111111111111111
111111111111111
111111111111111
111111111111111
111111111111111
111111111111111
111111111111111
111111111111111
111111111111111
111111111111111
111111111111111
111111111111111
111111111111111
 15
 */
